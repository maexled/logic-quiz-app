// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addQuizQuestion = `-- name: AddQuizQuestion :one
INSERT INTO
  user_quiz_questions (
    user_quiz_run_id,
    question,
    wrong_answers,
    correct_answer,
    given_answer,
    time_needed
  )
VALUES
  ($1, $2, $3, $4, $5, $6) RETURNING id, user_quiz_run_id, question, wrong_answers, correct_answer, given_answer, time_needed
`

type AddQuizQuestionParams struct {
	UserQuizRunID pgtype.Int8   `json:"userQuizRunId"`
	Question      string        `json:"question"`
	WrongAnswers  []string      `json:"wrongAnswers"`
	CorrectAnswer string        `json:"correctAnswer"`
	GivenAnswer   pgtype.Text   `json:"givenAnswer"`
	TimeNeeded    pgtype.Float8 `json:"timeNeeded"`
}

func (q *Queries) AddQuizQuestion(ctx context.Context, arg AddQuizQuestionParams) (UserQuizQuestion, error) {
	row := q.db.QueryRow(ctx, addQuizQuestion,
		arg.UserQuizRunID,
		arg.Question,
		arg.WrongAnswers,
		arg.CorrectAnswer,
		arg.GivenAnswer,
		arg.TimeNeeded,
	)
	var i UserQuizQuestion
	err := row.Scan(
		&i.ID,
		&i.UserQuizRunID,
		&i.Question,
		&i.WrongAnswers,
		&i.CorrectAnswer,
		&i.GivenAnswer,
		&i.TimeNeeded,
	)
	return i, err
}

const addQuizRun = `-- name: AddQuizRun :one
INSERT INTO
  user_quiz_runs (user_id)
VALUES
  ($1) RETURNING id, user_id, created_at
`

func (q *Queries) AddQuizRun(ctx context.Context, userID pgtype.Int8) (UserQuizRun, error) {
	row := q.db.QueryRow(ctx, addQuizRun, userID)
	var i UserQuizRun
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO
  questions (question, possible_answers, correct_answer)
VALUES
  ($1, $2, $3) RETURNING id, question, possible_answers, correct_answer
`

type CreateQuestionParams struct {
	Question        string   `json:"question"`
	PossibleAnswers []string `json:"possibleAnswers"`
	CorrectAnswer   string   `json:"correctAnswer"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion, arg.Question, arg.PossibleAnswers, arg.CorrectAnswer)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.PossibleAnswers,
		&i.CorrectAnswer,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
  users (username, email, password_hash)
VALUES
  ($1, $2, $3) RETURNING id, username, email, password_hash
`

type CreateUserParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"passwordHash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM
  users
WHERE
  id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAllQuizRuns = `-- name: GetAllQuizRuns :many
SELECT
  id, user_id, created_at
FROM
  user_quiz_runs
ORDER BY 
  created_at DESC
`

func (q *Queries) GetAllQuizRuns(ctx context.Context) ([]UserQuizRun, error) {
	rows, err := q.db.Query(ctx, getAllQuizRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuizRun{}
	for rows.Next() {
		var i UserQuizRun
		if err := rows.Scan(&i.ID, &i.UserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAmountQuizRunsPerDaySinceDate = `-- name: GetAmountQuizRunsPerDaySinceDate :many
SELECT
  DATE(created_at) AS date,
  COUNT(*) AS amount
FROM
  user_quiz_runs
WHERE
  created_at >= $1
GROUP BY
  date
`

type GetAmountQuizRunsPerDaySinceDateRow struct {
	Date   pgtype.Date `json:"date"`
	Amount int64       `json:"amount"`
}

func (q *Queries) GetAmountQuizRunsPerDaySinceDate(ctx context.Context, createdAt pgtype.Timestamptz) ([]GetAmountQuizRunsPerDaySinceDateRow, error) {
	rows, err := q.db.Query(ctx, getAmountQuizRunsPerDaySinceDate, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAmountQuizRunsPerDaySinceDateRow{}
	for rows.Next() {
		var i GetAmountQuizRunsPerDaySinceDateRow
		if err := rows.Scan(&i.Date, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostDifficultQuestions = `-- name: GetMostDifficultQuestions :many
SELECT
  question, 
  correct_answer, 
  SUM(CASE WHEN correct_answer = given_answer THEN 1 ELSE 0 END) AS correct_count,
  COUNT(question) AS total_count,
  (SUM(CASE WHEN correct_answer = given_answer THEN 1 ELSE 0 END) * 100 / COUNT(question))::float AS ratio
FROM
  user_quiz_questions
GROUP BY
  question, correct_answer
ORDER BY
  ratio DESC
LIMIT
  $1
`

type GetMostDifficultQuestionsRow struct {
	Question      string  `json:"question"`
	CorrectAnswer string  `json:"correctAnswer"`
	CorrectCount  int64   `json:"correctCount"`
	TotalCount    int64   `json:"totalCount"`
	Ratio         float64 `json:"ratio"`
}

func (q *Queries) GetMostDifficultQuestions(ctx context.Context, limit int32) ([]GetMostDifficultQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getMostDifficultQuestions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostDifficultQuestionsRow{}
	for rows.Next() {
		var i GetMostDifficultQuestionsRow
		if err := rows.Scan(
			&i.Question,
			&i.CorrectAnswer,
			&i.CorrectCount,
			&i.TotalCount,
			&i.Ratio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostEasiestQuestions = `-- name: GetMostEasiestQuestions :many
SELECT
  question, 
  correct_answer, 
  SUM(CASE WHEN correct_answer = given_answer THEN 1 ELSE 0 END) AS correct_count,
  COUNT(question) AS total_count,
  (SUM(CASE WHEN correct_answer = given_answer THEN 1 ELSE 0 END) * 100 / COUNT(question))::float AS ratio
FROM
  user_quiz_questions
GROUP BY
  question, correct_answer
ORDER BY
  ratio ASC
LIMIT
  $1
`

type GetMostEasiestQuestionsRow struct {
	Question      string  `json:"question"`
	CorrectAnswer string  `json:"correctAnswer"`
	CorrectCount  int64   `json:"correctCount"`
	TotalCount    int64   `json:"totalCount"`
	Ratio         float64 `json:"ratio"`
}

func (q *Queries) GetMostEasiestQuestions(ctx context.Context, limit int32) ([]GetMostEasiestQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getMostEasiestQuestions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostEasiestQuestionsRow{}
	for rows.Next() {
		var i GetMostEasiestQuestionsRow
		if err := rows.Scan(
			&i.Question,
			&i.CorrectAnswer,
			&i.CorrectCount,
			&i.TotalCount,
			&i.Ratio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizQuestions = `-- name: GetQuizQuestions :many
SELECT
  id, user_quiz_run_id, question, wrong_answers, correct_answer, given_answer, time_needed
FROM
  user_quiz_questions
WHERE
  user_quiz_run_id = $1
`

func (q *Queries) GetQuizQuestions(ctx context.Context, userQuizRunID pgtype.Int8) ([]UserQuizQuestion, error) {
	rows, err := q.db.Query(ctx, getQuizQuestions, userQuizRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuizQuestion{}
	for rows.Next() {
		var i UserQuizQuestion
		if err := rows.Scan(
			&i.ID,
			&i.UserQuizRunID,
			&i.Question,
			&i.WrongAnswers,
			&i.CorrectAnswer,
			&i.GivenAnswer,
			&i.TimeNeeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizQuestionsWhereIDIsIn = `-- name: GetQuizQuestionsWhereIDIsIn :many
SELECT
  id, user_quiz_run_id, question, wrong_answers, correct_answer, given_answer, time_needed
FROM
  user_quiz_questions
WHERE
  user_quiz_run_id = ANY($1::int[])
`

func (q *Queries) GetQuizQuestionsWhereIDIsIn(ctx context.Context, dollar_1 []int32) ([]UserQuizQuestion, error) {
	rows, err := q.db.Query(ctx, getQuizQuestionsWhereIDIsIn, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuizQuestion{}
	for rows.Next() {
		var i UserQuizQuestion
		if err := rows.Scan(
			&i.ID,
			&i.UserQuizRunID,
			&i.Question,
			&i.WrongAnswers,
			&i.CorrectAnswer,
			&i.GivenAnswer,
			&i.TimeNeeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizRuns = `-- name: GetQuizRuns :many
SELECT
  id, user_id, created_at
FROM
  user_quiz_runs
WHERE
  user_id = $1
ORDER BY 
  created_at DESC
`

func (q *Queries) GetQuizRuns(ctx context.Context, userID pgtype.Int8) ([]UserQuizRun, error) {
	rows, err := q.db.Query(ctx, getQuizRuns, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuizRun{}
	for rows.Next() {
		var i UserQuizRun
		if err := rows.Scan(&i.ID, &i.UserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizRunsRatioAndTimeSinceDateFromUser = `-- name: GetQuizRunsRatioAndTimeSinceDateFromUser :many
SELECT
  user_quiz_runs.id AS quiz_run_id,
  COUNT(*) FILTER (
    WHERE
      user_quiz_questions.given_answer = user_quiz_questions.correct_answer
  ) AS correct_answers_count,
  COUNT(*) AS total_questions_count,
  SUM(user_quiz_questions.time_needed) AS total_time
FROM
  user_quiz_runs JOIN user_quiz_questions ON user_quiz_runs.id = user_quiz_questions.user_quiz_run_id
WHERE
  user_id = $1
AND
  created_at >= $2
GROUP BY
  user_quiz_runs.id
ORDER BY
  created_at DESC
`

type GetQuizRunsRatioAndTimeSinceDateFromUserParams struct {
	UserID    pgtype.Int8        `json:"userId"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
}

type GetQuizRunsRatioAndTimeSinceDateFromUserRow struct {
	QuizRunID           int64 `json:"quizRunId"`
	CorrectAnswersCount int64 `json:"correctAnswersCount"`
	TotalQuestionsCount int64 `json:"totalQuestionsCount"`
	TotalTime           int64 `json:"totalTime"`
}

func (q *Queries) GetQuizRunsRatioAndTimeSinceDateFromUser(ctx context.Context, arg GetQuizRunsRatioAndTimeSinceDateFromUserParams) ([]GetQuizRunsRatioAndTimeSinceDateFromUserRow, error) {
	rows, err := q.db.Query(ctx, getQuizRunsRatioAndTimeSinceDateFromUser, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuizRunsRatioAndTimeSinceDateFromUserRow{}
	for rows.Next() {
		var i GetQuizRunsRatioAndTimeSinceDateFromUserRow
		if err := rows.Scan(
			&i.QuizRunID,
			&i.CorrectAnswersCount,
			&i.TotalQuestionsCount,
			&i.TotalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizRunsSinceDate = `-- name: GetQuizRunsSinceDate :many
SELECT
  id, user_id, created_at
FROM
  user_quiz_runs
WHERE
  created_at >= $1
ORDER BY 
  created_at DESC
`

func (q *Queries) GetQuizRunsSinceDate(ctx context.Context, createdAt pgtype.Timestamptz) ([]UserQuizRun, error) {
	rows, err := q.db.Query(ctx, getQuizRunsSinceDate, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuizRun{}
	for rows.Next() {
		var i UserQuizRun
		if err := rows.Scan(&i.ID, &i.UserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizRunsWithLimit = `-- name: GetQuizRunsWithLimit :many
SELECT
  id, user_id, created_at
FROM
  user_quiz_runs
WHERE
  user_id = $1
ORDER BY
  created_at DESC
LIMIT
  $2
`

type GetQuizRunsWithLimitParams struct {
	UserID pgtype.Int8 `json:"userId"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetQuizRunsWithLimit(ctx context.Context, arg GetQuizRunsWithLimitParams) ([]UserQuizRun, error) {
	rows, err := q.db.Query(ctx, getQuizRunsWithLimit, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuizRun{}
	for rows.Next() {
		var i UserQuizRun
		if err := rows.Scan(&i.ID, &i.UserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
  id, username, email, password_hash
FROM
  users
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id, username, email, password_hash
FROM
  users
WHERE
  email = $1
LIMIT
  1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
  id, username, email, password_hash
FROM
  users
WHERE
  username = $1
LIMIT
  1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const getUserQuizRunRanking = `-- name: GetUserQuizRunRanking :many
WITH user_quiz_runs_aggregate AS (
  SELECT
    user_quiz_runs.user_id AS user_id,
    users.username AS username,
    user_quiz_runs.id AS quiz_run_id,
    SUM(user_quiz_questions.time_needed) AS total_time,
    COUNT(*) FILTER (
      WHERE
        user_quiz_questions.given_answer = user_quiz_questions.correct_answer
    ) AS correct_answers_count,
    COUNT(*) AS total_questions_count
  FROM
    user_quiz_questions
    JOIN user_quiz_runs ON user_quiz_runs.id = user_quiz_questions.user_quiz_run_id
    JOIN users ON users.id = user_quiz_runs.user_id
  WHERE 
    user_id IS NOT NULL
  GROUP BY
    user_quiz_runs.user_id,
    users.username,
    user_quiz_runs.id
),
ranked_user_quiz_runs AS (
  SELECT
    user_id,
    username,
    total_time,
    correct_answers_count,
    total_questions_count,
    ROW_NUMBER() OVER (
      PARTITION BY user_id
      ORDER BY
        correct_answers_count DESC,
        total_time ASC
    ) AS user_quiz_rank -- rank per user their quiz runs
  FROM
    user_quiz_runs_aggregate
)
SELECT
  user_id,
  username,
  total_time,
  correct_answers_count,
  total_questions_count,
  RANK () OVER (
    ORDER BY
      correct_answers_count DESC,
      total_time ASC
  ) AS rank -- rank each user based on each users best quiz run
FROM
  ranked_user_quiz_runs
WHERE
  user_quiz_rank = 1 -- select per user only their best quiz run
ORDER BY
  correct_answers_count DESC
LIMIT
  $1
`

type GetUserQuizRunRankingRow struct {
	UserID              pgtype.Int8 `json:"userId"`
	Username            string      `json:"username"`
	TotalTime           int64       `json:"totalTime"`
	CorrectAnswersCount int64       `json:"correctAnswersCount"`
	TotalQuestionsCount int64       `json:"totalQuestionsCount"`
	Rank                int64       `json:"rank"`
}

func (q *Queries) GetUserQuizRunRanking(ctx context.Context, limit int32) ([]GetUserQuizRunRankingRow, error) {
	rows, err := q.db.Query(ctx, getUserQuizRunRanking, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserQuizRunRankingRow{}
	for rows.Next() {
		var i GetUserQuizRunRankingRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TotalTime,
			&i.CorrectAnswersCount,
			&i.TotalQuestionsCount,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestions = `-- name: ListQuestions :many
SELECT
  id, question, possible_answers, correct_answer
FROM
  questions
`

func (q *Queries) ListQuestions(ctx context.Context) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.PossibleAnswers,
			&i.CorrectAnswer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsRandomWithLimit = `-- name: ListQuestionsRandomWithLimit :many
SELECT
  id, question, possible_answers, correct_answer
FROM
  questions
ORDER BY
  RANDOM()
LIMIT
  $1
`

func (q *Queries) ListQuestionsRandomWithLimit(ctx context.Context, limit int32) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsRandomWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.PossibleAnswers,
			&i.CorrectAnswer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
  id, username, email, password_hash
FROM
  users
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCredentials = `-- name: UpdateCredentials :exec
UPDATE
  users
set
  password_hash = $2
WHERE
  id = $1
`

type UpdateCredentialsParams struct {
	ID           int64  `json:"id"`
	PasswordHash string `json:"passwordHash"`
}

func (q *Queries) UpdateCredentials(ctx context.Context, arg UpdateCredentialsParams) error {
	_, err := q.db.Exec(ctx, updateCredentials, arg.ID, arg.PasswordHash)
	return err
}
